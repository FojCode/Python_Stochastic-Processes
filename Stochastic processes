# Ornstein Uhlenbeck process 
import numpy as np

def orenstein_uhlenbeck(mu, theta, sigma, dt, T, initial_state):
  """
  This function simulates the Ornstein-Uhlenbeck process using the Euler-Maruyama method.

  Args:
      mu: The mean reversion level of the process.
      theta: The rate at which the process reverts to the mean.
      sigma: The volatility of the process.
      dt: The time step for simulation.
      T: The total simulation time.
      initial_state: The initial state of the process.

  Returns:
      A numpy array representing the simulated OU process path.
  """
  n_steps = int(T / dt) + 1  # Number of steps (including initial state)
  process_path = np.zeros(n_steps)
  process_path[0] = initial_state

# Simulate using Euler-Maruyama method
  for i in range(1, n_steps):
    drift = theta * (mu - process_path[i-1]) * dt
    diffusion = sigma * np.random.normal(scale=np.sqrt(dt))
    process_path[i] = process_path[i-1] + drift + diffusion

  return process_path

# Example usage
mu = 0.5
theta = 1.0
sigma = 0.2
dt = 0.01
T = 10.0
initial_state = 1.0

process_path = orenstein_uhlenbeck(mu, theta, sigma, dt, T, initial_state)

# Plot the simulated path (using matplotlib)
import matplotlib.pyplot as plt
t = np.arange(0, T + dt, dt)
plt.plot(t, process_path)
plt.xlabel("Time")
plt.ylabel("Process value")
plt.title("Simulated Ornstein-Uhlenbeck Process")
plt.grid(True)
plt.show()

# Monte Carlo simulation - box Muller formulae 
import numpy as np

def box_muller(u1, u2):
  """
  This function generates two independent standard normal variables using the Box-Muller transform.

  Args:
      u1: A random number uniformly distributed between 0 and 1.
      u2: Another random number uniformly distributed between 0 and 1 (independent of u1).

  Returns:
      A tuple containing two independent standard normal variables (z1, z2).
  """
  z1 = np.sqrt(-2 * np.log(u1)) * np.cos(2 * np.pi * u2)
  z2 = np.sqrt(-2 * np.log(u1)) * np.sin(2 * np.pi * u2)
  return z1, z2

# Example usage
u1 = np.random.rand()  # Generate a random number between 0 and 1
u2 = np.random.rand()  # Generate another independent random number between 0 and 1

z1, z2 = box_muller(u1, u2)

print(f"Standard normal variable 1: {z1}")
print(f"Standard normal variable 2: {z2}")

# monte Carlo simulation - polar method
import numpy as np

def polar_method(n_samples, a, b):
  """
  This function generates random samples within a rectangle using the polar method.

  Args:
      n_samples: The number of samples to generate.
      a: The lower bound of the rectangle (x-axis).
      b: The upper bound of the rectangle (x-axis).

  Returns:
      A tuple containing two numpy arrays:
          - x: The generated x-coordinates within the rectangle.
          - y: The generated y-coordinates within the rectangle (uniformly distributed).
  """
  # Generate uniform random variables
  u1 = np.random.rand(n_samples)
  u2 = np.random.rand(n_samples)

# Apply polar transformation
  theta = 2 * np.pi * u1  # Random angles between 0 and 2*pi
  radius = np.sqrt(u2)  # Radius based on second uniform random variable

  # Convert to rectangular coordinates (x, y)
  x = a + radius * b * np.cos(theta)
  y = radius * np.sin(theta)

  return x, y

# Example usage
n_samples = 1000
a = 0.0
b = 1.0

x, y = polar_method(n_samples, a, b)

# Plot the generated samples (using matplotlib)
import matplotlib.pyplot as plt

plt.scatter(x, y)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Polar Method Samples within Rectangle")
plt.grid(True)
plt.show()
