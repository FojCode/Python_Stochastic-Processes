# Brownian motion hitting times - method 1
import numpy as np

def hitting_time_loop(n_steps, sigma, boundary):
  """
  This function simulates the hitting time of Brownian motion using a loop.

  Args:
      n_steps: The number of steps in the simulation.
      sigma: The standard deviation of the increments (diffusion coefficient).
      boundary: The hitting level (positive or negative).

  Returns:
      The hitting time (step number) or None if not reached within n_steps.
  """
  bm_path = sigma * np.random.normal(scale=1/np.sqrt(2), size=n_steps)  # Efficient generation using Box-Muller method
  for i in range(n_steps):
    if (boundary > 0 and bm_path[i] >= boundary) or (boundary < 0 and bm_path[i] <= boundary):
      return i + 1  # Return step number (1-based indexing)
  return None

# Example usage
n_steps = 1000
sigma = 0.2
boundary = 1.0

hitting_time = hitting_time_loop(n_steps, sigma, boundary)

if hitting_time is not None:
  print(f"Hitting time for boundary {boundary}: {hitting_time}")
else:
  print(f"Boundary {boundary} not reached within {n_steps} steps.")

# Brownian motion hitting times - method 2

from scipy.optimize import minimize

def hitting_time_minimize(n_steps, sigma, boundary):
  """
  This function simulates the hitting time of Brownian motion using minimization.

  Args:
      n_steps: The number of steps in the simulation (represents maximum time).
      sigma: The standard deviation of the increments (diffusion coefficient).
      boundary: The hitting level (positive or negative).

  Returns:
      The hitting time (step number) or None if not reached within n_steps.
  """
  def distance_to_boundary(x):
    # Objective function: distance between current value (x) and boundary
    return np.abs(x - boundary)

  # Simulate Brownian motion path
  bm_path = sigma * np.random.normal(scale=1/np.sqrt(2), size=n_steps)
  # Simulate Brownian motion path
  bm_path = sigma * np.random.normal(scale=1/np.sqrt(2), size=n_steps)

  # Find minimum distance (hitting time) using minimization
  res = minimize(distance_to_boundary, bm_path[0], method='Nelder-Mead')
  hitting_time = int(res.x[0])  # Assuming minimum corresponds to hitting time
  
  # Check if minimum is within the path (avoiding minimization errors)
  if hitting_time >= 0 and hitting_time < n_steps and np.abs(bm_path[hitting_time] - boundary) < 1e-5:
    return hitting_time + 1  # Return step number (1-based indexing)
  else:
    return None

# Example usage (same as previous example)
n_steps = 1000
sigma = 0.2
boundary = 1.0

hitting_time = hitting_time_minimize(n_steps, sigma, boundary)

if hitting_time is not None:
  print(f"Hitting time for boundary {boundary}: {hitting_time}")
else:
  print(f"Boundary {boundary} not reached within {n_steps} steps.")

# Ornstein Uhlenbeck process 
import numpy as np

def orenstein_uhlenbeck(mu, theta, sigma, dt, T, initial_state):
  """
  This function simulates the Ornstein-Uhlenbeck process using the Euler-Maruyama method.

  Args:
      mu: The mean reversion level of the process.
      theta: The rate at which the process reverts to the mean.
      sigma: The volatility of the process.
      dt: The time step for simulation.
      T: The total simulation time.
      initial_state: The initial state of the process.

  Returns:
      A numpy array representing the simulated OU process path.
  """
  n_steps = int(T / dt) + 1  # Number of steps (including initial state)
  process_path = np.zeros(n_steps)
  process_path[0] = initial_state

# Simulate using Euler-Maruyama method
  for i in range(1, n_steps):
    drift = theta * (mu - process_path[i-1]) * dt
    diffusion = sigma * np.random.normal(scale=np.sqrt(dt))
    process_path[i] = process_path[i-1] + drift + diffusion

  return process_path

# Example usage
mu = 0.5
theta = 1.0
sigma = 0.2
dt = 0.01
T = 10.0
initial_state = 1.0

process_path = orenstein_uhlenbeck(mu, theta, sigma, dt, T, initial_state)

# Plot the simulated path (using matplotlib)
import matplotlib.pyplot as plt
t = np.arange(0, T + dt, dt)
plt.plot(t, process_path)
plt.xlabel("Time")
plt.ylabel("Process value")
plt.title("Simulated Ornstein-Uhlenbeck Process")
plt.grid(True)
plt.show()

# Monte Carlo simulation - box Muller formulae 
import numpy as np

def box_muller(u1, u2):
  """
  This function generates two independent standard normal variables using the Box-Muller transform.

  Args:
      u1: A random number uniformly distributed between 0 and 1.
      u2: Another random number uniformly distributed between 0 and 1 (independent of u1).

  Returns:
      A tuple containing two independent standard normal variables (z1, z2).
  """
  z1 = np.sqrt(-2 * np.log(u1)) * np.cos(2 * np.pi * u2)
  z2 = np.sqrt(-2 * np.log(u1)) * np.sin(2 * np.pi * u2)
  return z1, z2

# Example usage
u1 = np.random.rand()  # Generate a random number between 0 and 1
u2 = np.random.rand()  # Generate another independent random number between 0 and 1

z1, z2 = box_muller(u1, u2)

print(f"Standard normal variable 1: {z1}")
print(f"Standard normal variable 2: {z2}")

# monte Carlo simulation - polar method
import numpy as np

def polar_method(n_samples, a, b):
  """
  This function generates random samples within a rectangle using the polar method.

  Args:
      n_samples: The number of samples to generate.
      a: The lower bound of the rectangle (x-axis).
      b: The upper bound of the rectangle (x-axis).

  Returns:
      A tuple containing two numpy arrays:
          - x: The generated x-coordinates within the rectangle.
          - y: The generated y-coordinates within the rectangle (uniformly distributed).
  """
  # Generate uniform random variables
  u1 = np.random.rand(n_samples)
  u2 = np.random.rand(n_samples)

# Apply polar transformation
  theta = 2 * np.pi * u1  # Random angles between 0 and 2*pi
  radius = np.sqrt(u2)  # Radius based on second uniform random variable

  # Convert to rectangular coordinates (x, y)
  x = a + radius * b * np.cos(theta)
  y = radius * np.sin(theta)

  return x, y

# Example usage
n_samples = 1000
a = 0.0
b = 1.0

x, y = polar_method(n_samples, a, b)

# Plot the generated samples (using matplotlib)
import matplotlib.pyplot as plt

plt.scatter(x, y)
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Polar Method Samples within Rectangle")
plt.grid(True)
plt.show()
